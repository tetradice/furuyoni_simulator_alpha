import { ActionResult } from "hyperapp";

export as namespace hyperappExt


// /** Action implements type (for verification) */
// export type ActionImplements<Self, State> = {[key in keyof Self]: ActionImplementItem<Self, State, key>}

// type ActionImplementItem<ActionImpls, State, PropName extends keyof ActionImpls> = (
//     ((data?: any) => (state: State, actions: object) => ActionResult<State>)
//     |
//     ((data?: any) => ActionResult<State>)
//     |
//     NestedActionImplements<ActionImpls, State, PropName>
// )

// type NestedActionImplements<ActionImpls, State, PropName extends keyof ActionImpls> = (
//     PropName extends (keyof State) ? ActionImplements<ActionImpls[PropName], State[PropName]> : never
// )



/** Wired actions type (generated by type of action implements) */
export type WiredActions<State, ActImpls> = {[key in keyof ActImpls]: WiredActionItem<State, ActImpls, key, ActImpls[key]>}

type WiredActionItem<State, ActImpls, PropName extends (keyof ActImpls), A> = (
    // without parameter
    A extends (() => (state: State, actions: infer A2) => (infer R))              ? (() => R)        :
    A extends (() => (infer R))                                                   ? (() => R)        :
    // with parameter
    A extends ((data: infer P) => (state: State, actions: infer A2) => (infer R)) ? ((data: P) => R) :
    A extends ((data: infer P) => (infer R))                                      ? ((data: P) => R) :
    // nested actions
    PropName extends (keyof State) ? WiredActions<State[PropName], ActImpls[PropName]> :
    'ERROR: invalid action type'
)

/** extract parameter type from action */
export type ParamType<A> = (
    A extends ((data: infer P) => any) ? P :
    never
)
